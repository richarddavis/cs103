%Modified from a template provided by Jennifer Pan, August 2011

\documentclass[10pt,letter]{article}
	% basic article document class
	% use percent signs to make comments to yourself -- they will not show up.
\usepackage{pdfsync}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ mathrsfs }
	% packages that allow mathematical formatting


\usepackage{graphicx}
	% package that allows you to include graphics
\graphicspath{ {./images/} }

\usepackage{setspace}
	% package that allows you to change spacing

\onehalfspacing
	% text become 1.5 spaced

\usepackage{fullpage}
% package that specifies normal margins

\usepackage[parfill]{parskip}

\usepackage{cancel}

\newtheorem*{thm}{Theorem}
\newtheorem{nthm}{Theorem}

\begin{document}
	% line of code telling latex that your document is beginning

\title{Problem Set 7: CS103}

\author{Katherine Cheng, Richard Davis, Marty Keil}

% \date{Friday April 10, 2015}
	% Note: when you omit this command, the current date is automatically included
 
\maketitle
	% tells latex to follow your header (e.g., title, author) commands.

\section*{Problem 1}
Richard Davis (rldavis) submitted this turing machine.
\section*{Problem 2}
Richard Davis (rldavis) submitted these turing machines.
\section*{Problem 3}
\paragraph{i}
\begin{proof}
Let the turing machine M reject any input. It is then a decider, because M halts on all inputs by rejecting. Also for any string w, the statement if M accepts w, then x $\in$ $\Sigma$* is always a true statement because M never accepts w. A truth table is always true when the antecedent of an implication is false. 
\end{proof}
\paragraph{ii}
\begin{proof}
Let the turing machine M accept any input. It is then a decider, because M halts on all inputs by accepting. Also for any string w, the statement if M rejects w, then x $\notin$ $\Sigma$* is always a true statement because M accepts all w. A truth table is always true when the consequent of an implication is true. 
\end{proof}
\paragraph{iii}
\begin{proof}
Let the turing machine M infinitely loop on any input. Both Statements 2 and 3 are always true in this case because both antecedents in the implications are always false. M never accepts any string w and M never rejects any string w. As before, the truth table is always true when the antecedent of an implication is false. 
\end{proof}
\paragraph{iv}
If L satisfies all 3 statements then we know the language is decidable. We then also know that L $\in$ R. And since R is a subset of RE, we can also state that L is recognizable. 

\section*{Problem 4}
\begin{enumerate}
\item[i. ] We can create a TM $M$ that accepts an arbitrary string $w$ and loops infinitely on all other inputs. $M$ is constructed such that $\mathscr{L}(M)$ = \{$w$\}. Because $M$ does not halt on all inputs, $M$ is not a decider. 

We can create a second TM $N$ that accepts the string $w$ and rejects all other inputs. The language of $N$ is $\mathscr{L}(N)$ = \{$w$\}. Since $N$ halts on all inputs, $N$ is a decider. By definition, a language L is called decidable if there is a decider N such that $\mathscr{L}(N)$ = L, so $\mathscr{L}(N)$ is decidable. 

Because we defined $\mathscr{L}(M) = \mathscr{L}(N) = \{$w$\}$, we know that $\mathscr{L}(M)$ is must be decidable. Thus, we have described a TM $M$ where $\mathscr{L}(M) \in \textbf{R}$, but $M$ is not a decider.

\item[ii. ] 
\begin{thm} For every string $w$, there's an \textbf{R} and an \textbf{RE} language containing $w$.\end{thm}
\begin{proof} Take the second TM, $N$, described in part i of this problem. For any arbitrary string $w$, $N$ accepts $w$ and rejects all other inputs. $N$ halts on all inputs, so $N$ is a decider. Let L = $\mathscr{L}(N)$. Since $N$ is a decider, L is decidable, which means that $L \in \textbf{R}$. 

We also know that $\textbf{R} \subseteq \textbf{RE}$, and by definition of a subset, all elements of $\textbf{R}$ are also elements of $\textbf{RE}$. As such, we know that $L \in \textbf{RE}$. Thus, we have shown that for every string $w$, there exists an \textbf{R} language containing $w$ and an \textbf{RE} language containing $w$, namely L.
\end{proof}
\end{enumerate}

\section*{Problem 5}
If we wanted to build a TM password checker, “entering your password” would correspond to starting up the TM on some string, and “gaining access” would mean that the TM accepts your string. Let $p \in \Sigma^*$ be your password. A TM that would work as a valid password checker would be a TM $M$ where $L(M) = {p}$; the TM accepts your string, and it doesn't accept anything else.

Given a TM, is there some way you could tell whether the TM was a valid password checker? Let $p \in \Sigma^*$ be your password and consider the following language: $$ L = \{ \langle M \rangle \ | \ M \text{ is a TM and } L(M) = \{p\}\}.$$ Prove that $L$ is undecidable. This means there is no algorithm that can mechanically check whether TM is suitable as a password checker.

\paragraph{i.} Suppose there is a function \texttt{bool isPasswordChecker(string program)} that accepts as input a program and returns whether or not that program only accepts the string $p$. Using the programs from lecture as a template, write the pseudocode for a self-referential program that uses the \texttt{isPasswordChecker} method to obtain a contradiction. 

\texttt{isPasswordChecker(isPasswordChecker)}

\paragraph{ii.} 

\section*{Problem 6}
In class we learned about the halting problem, which tells us that it is not possible to write a decider that will determine if a program halts or loops forever. This means it is not possible for the operating system to detect when a program has gone into an infinite loop, because that would require it to have access to this impossible decider. So, the best the operating system can do is to pop up a dialog asking if it should terminate a program. 

\section*{Problem 7}

Consider the program:
{\fontfamily{qcr}\selectfont

$\qquad$int main() \{\\
$\qquad$$\qquad$string me = mySource();\\
$\qquad$$\qquad$string input = getInput();\\
$\qquad$$\qquad$if (willAccept(me, input)) \{\\
$\qquad$$\qquad$$\qquad$reject();\\
$\qquad$$\qquad$\} else \{\\
$\qquad$$\qquad$$\qquad$accept();\\
$\qquad$$\qquad$\}\\
$\qquad$\}
}
\begin{thm}This program must loop infinitely on all inputs.\end{thm}
\begin{proof}
By contradiction. Assume for the sake of contradiction that there exists some string $w$ that causes the program to terminate. If the program terminates, it must accept or reject $w$. 

In the case that the program accepts the input $w$, it satisfies the conditional {\fontfamily{qcr}\selectfont if (willAccept (me, input))}, which causes the program to {\fontfamily{qcr}\selectfont reject()}. This is a contradiction, because the method {\fontfamily{qcr}\selectfont willAccept()} returns true when the program in fact rejects the input.

Alternatively, in the case that the program rejects the input $w$, it does not satisfy the conditional and is punted to the {\fontfamily{qcr}\selectfont else} case, and the program will {\fontfamily{qcr}\selectfont accept()}. This is a contradiction, because the method {\fontfamily{qcr}\selectfont willAccept()} returns false, whereas the program accepts the input.

Both cases lead to a contradiction, so our assumption must be false. There must not exist a string $w$ that causes the program to terminate. Thus, this means that the program loops infinitely on all inputs. 
\end{proof}
\section*{Problem 8}
\paragraph{i}
\ \\
{\fontfamily{qcr}\selectfont
$\qquad$function bool inL1uL2(string w) \{ \\
$\qquad$$\qquad$  inL1(w) OR inL2(w); \\
$\qquad$\} \\}
From this new method we can see that L1 $\cup$ L2 is also decidable. When either L1(w) or L2(w) is accepted, inL1uL2 returns true. If both L1(w) and L2(w) are rejected then inL1uL2 returns false. This covers all possibilities and always returns either an accepting or rejecting state, so the method is therefore decidable. 

\paragraph{ii}
\ \\
{\fontfamily{qcr}\selectfont
$\qquad$function bool Concat (string w)  \{  \\
$\qquad$$\qquad$for all L1 \{ \\
$\qquad$$\qquad$ $\qquad$for all L2 \{ \\
$\qquad$$\qquad$$\qquad$$\qquad$for ( i = 0; i++; i $<$ w.length) \{ \\	
$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$string firstpart = w.split at i and take first part\\
$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$string secondpart = w.split at i and take second part\\
$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$if (inL1(firstpart) AND inL2(secondpart)\{ \\
$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$return true;\\
$\qquad$$\qquad$$\qquad$$\qquad$$\qquad$\} \\
$\qquad$$\qquad$$\qquad$$\qquad$\} \\ 
$\qquad$$\qquad$$\qquad$\} \\
$\qquad$$\qquad$\} return false; \\
$\qquad$\} \\
This method represents a concatenation of inL1inL2. The method returns true whenever the string w can be split and one part is accepted by inL1 and the other is accepted by in L2. Otherwise it will return false. This covers all possibilities and always returns either an accepting or rejecting state, so the method is therefore decidable. 

\paragraph{iii}
\ \\
{\fontfamily{qcr}\selectfont
$\qquad$function bool SymDiff (string w) \{  \\
$\qquad$$\qquad$for all L1, L2 \{\\
$\qquad$$\qquad$ $\qquad$ if (inL1(w) OR inL2(w)) \{ \\
$\qquad$$\qquad$ $\qquad$ $\qquad$ if( !( inL1(w) AND inL2(w))  \{ \\
$\qquad$$\qquad$ $\qquad$ $\qquad$ $\qquad$ return true; \\
$\qquad$$\qquad$ $\qquad$ $\qquad$\} \\
$\qquad$$\qquad$	$\qquad$	\}  \\
$\qquad$$\qquad$ \} return false;\\
$\qquad$\}

This method returns true whenever inL1 or inL2 accepts, but not when inL1 and inL2 both accept. In this case and also when both reject, the method rejects. This covers all possibilities and always returns either an accepting or rejecting state, so the method is therefore decidable. 
			

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
