%Modified from a template provided by Jennifer Pan, August 2011

\documentclass[10pt,letter]{article}
	% basic article document class
	% use percent signs to make comments to yourself -- they will not show up.
\usepackage{pdfsync}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ mathrsfs }
\usepackage{upgreek}
	% packages that allow mathematical formatting


\usepackage{graphicx}
	% package that allows you to include graphics
\graphicspath{ {./images/} }

\usepackage{setspace}
	% package that allows you to change spacing

\onehalfspacing
	% text become 1.5 spaced

\usepackage{fullpage}
% package that specifies normal margins

\usepackage[parfill]{parskip}

\usepackage{listings}

\usepackage{cancel}

\newtheorem*{thm}{Theorem}
\newtheorem{nthm}{Theorem}

\begin{document}
	% line of code telling latex that your document is beginning

\title{Problem Set 8: CS103}

\author{Katherine Cheng, Richard Davis, Marty Keil}

% \date{Friday April 10, 2015}
	% Note: when you omit this command, the current date is automatically included
 
\maketitle
	% tells latex to follow your header (e.g., title, author) commands.

\section*{Problem 1: Closure Properties of RE}

\begin{enumerate}
\item[i.] 
{\fontfamily{qcr}\selectfont
$\qquad$bool inL1nL2(string w) \{\\
$\qquad$$\qquad$return inL1(w) \&\& inL2(w);\\
$\qquad$\}
}

This method, which models the language L1 $cap$ L2, satisfies the properties of a recognizer. When $w \in L1 $cap$ L2$ the method will return true, and the method returns false or loops infinitely otherwise.
\item[ii.] Since the RE languages are closed under union, we would expect L1 $\cup$ L2 to be recognizable. By definition of a recognizable language, this means that the method should return true for any string $w \in L1 \cup L2$. Because the line {\fontfamily{qcr}\selectfont return inL1(w) || inL2(w);} evaluates left to right, if {\fontfamily{qcr}\selectfont inL1(w)} enters an infinite loop, the statement will never evaluate the second function, {\fontfamily{qcr}\selectfont inL2(w)}. If {\fontfamily{qcr}\selectfont inL2(w)} evaluates to true, the recognizer should return true - however, since this portion of the statement is never evaluated, this method not properly model the behavior of a recognizer.
\item[iii.] 
{\fontfamily{qcr}\selectfont
$\qquad$bool imConvincedIsInL1uL2(string w, string c) \{\\
$\qquad$$\qquad$return imConvincedIsInL1(w, c) $||$  imConvincedIsInL2(w, c);\\
$\qquad$\}
}

As opposed to the method in part ii of this problem, this new method {\fontfamily{qcr}\selectfont imConvincedIsInL1uL2()} will not get caught in an infinite loop. This is because both {\fontfamily{qcr}\selectfont imConvincedIsInL1(w, c)} and {\fontfamily{qcr}\selectfont imConvincedIsInL2(w, c)} always return a true or false value, so the return statement evaluates both sides of the `or' properly.
\end{enumerate}

\section*{Problem 2: Password Checking}
\begin{enumerate}
\item[1.] 
meta level - by contradiction that password checking language is RE/verifiable. Then we can create this. now (i). there is some certificate c where imConvinced will return true, we accept(). If we accept, the language of the machine is (we have 2 levels of machines, (1) candidate password checkers, (2) looks at machines and says if it's a password checker) higher machine has said you're only going to accept p. Now, reach a contradiction. If we are a passwordchecker, just accepts always regardless of the input. input of the machine is everything.

contradiction: if it is a password checker then it accepts all inputs
\item[2.]
it'll infinitely loop 

we're guaranteed the pass checker returns p and only p

if we loop infinitely on every string, 
\item[3.]
input equal to p?
\end{enumerate}

\section*{Problem 3: Equivalent TMs}
m1 takes an input, it will accept/reject/loop
m2 has some other language
if imConvinced true, then language does not match what you have coded


\begin{enumerate}
\item[1.] REG
\item[2.] ALL
\item[3.] REG
\item[4.] REG
\item[5.] REG (regular languages closed under union)
\item[6.] R (M-N so not REG, but CFG so R)
\item[7.] RE (?)
\item[8.] ALL (there is a TM where L=\{$\emptyset$\} will loop forever, can't be RE)
\item[9.] RE (n is the certificate) (what happens when it loops? don't worry about that)
\item[10.] ALL
\item[11.] ALL
\item[12.] RE 
\end{enumerate}
if in RE, if I give you a machine, deep down I know this is in the machine, machine will halt. R if not in language, will halt, which is not guaranteed. Not in RE, I can give you (M,n) that's in the language and you can't conclusively tell me it's in the language. ex) at most length 5, run on all strings on at most length 5, if in language, will accept it. I'm giving you something in the language, if you halt

\section*{Problem 4: The Big Picture}

\section*{Problem 5: 4-Colorability}
\begin{enumerate}
\item[1.]
\item[2.]
\end{enumerate}
3COLOR polynomial time reducible to 4COLOR
\section*{Problem 6: Resolving P $\stackrel{?}{=}$ NP}

\begin{enumerate}
\item[1.] neither
\item[2.] neither
\item[3.] P = NP
\item[4.] P = NP
\item[5.] P $\neq$ NP
\item[6.] P $\neq$ NP
\item[7.] neither
\item[8.] neither
\item[9.] neither
\item[10.] neither
\item[11.] neither
\item[12.] neither
\item[13.] P = NP
\item[14.] P = NP
\item[15.] neither
\item[16.] neither
\end{enumerate}

\section*{Problem 7: The Big Picture}
\begin{enumerate}
\item[i.] \{$a^n\ |\ n \in \mathbb{N}$\} is an example of a regular language. You can prove that this language is regular by creating a regular expression for it, namely $a^*$. We could also have proven the language is regular by creating a DFA or NFA for it.
\item[ii.] \{$a^nb^n\ |\ n \in \mathbb{N}$\} is an example of a context-free language that is not regular. You can prove that it is context free by providing the context-free grammar, aka production rules, for deriving the language. The CFG for this example is $S \rightarrow aSb | \epsilon$. We can prove that this language is not regular using the Myhill-Nerode Theorem.
\item[iii.]  \{$a^n\ |\ n \in \mathbb{N}$\} is an example of a language in P. Since we know this language is a regular language, and regular languages $\subseteq$ P, it follows that the language is in P. In general, you can prove a language is in P by creating a Turing machine decider for the language that decides in polynomial time.

\item[iv.] INDSET = \{$\langle G, n \rangle\ |\ G$ is an undirected graph with an independent set of size at least $n$\} is an example of a language in NP that is not known to be in P. You can prove INDSET is in NP by building a polynomial-time verifier for the language. For this language, the polynomial-time verifier checks whether S is an n-element independent set.

In general, you can prove that a language is in NP by building a polynomial-time verifier for the language. Specifically, you would create a NTM that nondeterministically guesses a certificate, then deterministically runs the verifier to check it. Then, you would argue that the NTM runs in nondeterministic polynomial time. 

We don't know whether INDSET is in P because INDSET $\in$ NP-complete. All known algorithms for NP-complete problems run in worst-case exponential time, and are infeasible for reasonably-sized inputs. We do not know whether INDSET is in P because P$\stackrel{?}{=}$NP.

\item[v.] $A_{TM}$, the language of the Universal Turing machine, is an example of a language in RE not contained in R. You can prove that $A_{TM}$ is RE by simulating the machine, which will accept if string $w$ is in the language of machine $M$, and reject/loop otherwise. You can prove that $A_{TM}$ is not contained in R by contradiction - you'd show that if there were a decider for $A_{TM}$, then you could construct a self-referential TM that flips its response based on the decider's answer, thus contradicting the decider in all cases.

\item[vi.] \{ $\langle M \rangle\ |\ M$ is a Turing machine and $L(M) = \emptyset$\} is an example of a language that is not in RE. You can prove it is not contained in RE by constructing a case of a TM where the language cannot be verified - for example, a TM that loops infinitely and does not halt.
\end{enumerate}
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
