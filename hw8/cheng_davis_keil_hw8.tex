%Modified from a template provided by Jennifer Pan, August 2011

\documentclass[10pt,letter]{article}
	% basic article document class
	% use percent signs to make comments to yourself -- they will not show up.
\usepackage{pdfsync}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ mathrsfs }
	% packages that allow mathematical formatting


\usepackage{graphicx}
	% package that allows you to include graphics
\graphicspath{ {./images/} }

\usepackage{setspace}
	% package that allows you to change spacing

\onehalfspacing
	% text become 1.5 spaced

\usepackage{fullpage}
% package that specifies normal margins

\usepackage[parfill]{parskip}

\usepackage{listings}

\usepackage{cancel}

\newtheorem*{thm}{Theorem}
\newtheorem{nthm}{Theorem}

\begin{document}
	% line of code telling latex that your document is beginning

\title{Problem Set 7: CS103}

\author{Katherine Cheng, Richard Davis, Marty Keil}

% \date{Friday April 10, 2015}
	% Note: when you omit this command, the current date is automatically included
 
\maketitle
	% tells latex to follow your header (e.g., title, author) commands.

\section*{Problem 1: Closure Properties of RE}

\begin{enumerate}
\item[i.] 
bool inL1nL2(string w) \{\\
return inL1(w) \&\& inL2(w);\\
\}

Will return true when true, returns false or loops infinitely otherwise.
\item[ii.] Evaluates left to right (confirm?), so if the first function is an infinite loop, will not evaluate the second function (which might be true)
\item[iii.] 
bool imConvincedIsInL1uL2(string w, string c) \{\\
return imConvincedIsInL1(w, c) $||$  imConvincedIsInL2(w, c);\\
\}

Now won't get caught in an infinite loop.
\end{enumerate}

\section*{Problem 2: Password Checking}

\paragraph{i.} We begin with the assumption that this program is a valid password checker. If this is the case, this means the program only accepts a single string $p$. However, because of the way this program is constructed, we see that if it is a valid password checker we will be able to find some certificate $c$ such that the program will always accept no matter the input string. This is a contradiction.

\paragraph{ii.} We begin with the assumption that this program is not a valid password checker. In this case, the program is constructed in a way that no matter what the input string is the program never accepts. This is consistent with the program not being a valid password checker.

\paragraph{iii.} The modified program is as follows:\\

\begin{lstlisting}
bool imConvincedIsPasswordChecker(string program, string certificate) { 
/* ... some implementation ... */ 
}

int main() {
    string me = mySource();
    string input = getInput();

    bool actualAnswer = (input == p);

    for (int i = 0 to infinity) {
        for (each string c of length i) {
            if (imConvincedIsPasswordChecker(me, c)) {                
                accept(); // Once the certificate is found, accept any input
            } else {
                if (actualAnswer) {
                    accept();
                } else {
                    reject();
                }
            }
        }
    }
}
\end{lstlisting}

This program leads to a contradiction regardless of whether it is a password checker. If the program is a password checker, by the same argument as in part i. we can show that this leads to a contradiciton. If the program is not a password checker, we know that \texttt{imConvincedIsPasswordChecker} returns false for all values of $c$. However, the program is constructed such that for all values of $c$, the program behaves like a password checker, only accepting input strings that are equal to $p$. In other words, if the program is not a password checker (as determined by \texttt{imConvincedIsPasswordChecker}) the program always behaves as a password checker. This is a contradiction. 

\paragraph{iv.} \begin{thm} $L \not \in $ \textbf{RE}. \end{thm}
\begin{proof} 

By contradiction; assume that $L \in$ \textbf{RE}. Then there is some verifier $V$ for $L$. This verifier has the property that if $M$ is a TM that is a password checker, there is a certificate $c$ such that $V$ accepts $\langle M, c \rangle$, and if $M$ is not a password checker, $V$ will never accept $\langle M, c \rangle$ for any certificate $c$.

Given this, we could then construct the following TM:
\begin{align*}
M = &\text{â€œOn input w:}\\
&\text{Have $M$ obtain its own description, $\langle M \rangle$. For all strings c:}\\
&\text{If $V$ accepts $\langle M, c \rangle$, accept.}\\
&\text{Otherwise, if $V$ does not accept $\langle M, c \rangle$, accept if the input string is equal to $p$ and return false otherwise.}
\end{align*}

Choose any string $w$ and trace through the execution of the machine. If $V$ ever accepts $\langle M, c \rangle$, we are guaranteed that $M$ only accepts $p$, but in this case we find that $M$ accepts any input, a contradiction. If $V$ never accepts $\langle M, c \rangle$, then we are guaranteed that $M$ is not a password checker, but in this case we find that $M$ always behaves as a password checker, a contradiction.

In both cases we reach a contradiction, so our assumption must have been wrong. Therefore, $L \not \in$ \textbf{RE}.

\section*{Problem 3: Equivalent TMs}

\paragraph{i.} 

\begin{lstlisting}
bool imConvincedAreEqual(string p1, string p2, string certificate) {
  // Returns true if p1 and p2 are both turing machines that have the same language, false otherwise.
}

bool simulateTM(string tm, string inp) {
  // simulate the tm run on the string inp and return whatever tm returns
}

int main() {
  string me = mySource();
  string m2 = getOtherTMSource();
  string input = getInput();

  for (i = 0 to infinity) {
    for (each string c of length i) {
      if (imConvincedAreEqual(me, m2, c)) {
	return !simulateTM(m2, input);
      } else {
	return simulateTM(m2, input);
      }
    }
  }
}
\end{lstlisting}

\section*{Problem 4: The Big Picture}

\section*{Problem 5: 4-Colorability}

\section*{Problem 6: Resolving P \stackrel{?}{=} NP}

\section*{Problem 7: The Big Picture}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
